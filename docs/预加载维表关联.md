## 预加载维表关联 <!-- {docsify-ignore} -->

预加载维表：在作业启动时，就将维表读取到内存中，而在后续运行期间，每条数据都会和内存中的维表进行关联，而不会直接访问数据库

与带缓存的数据库查询关联相比：

- 带缓存的数据库查询关联：如果不命中缓存，还可以fallback到数据库访问
- 预加载维表关联：不命中，就是关联不到数据

### 启动时预加载维表

在作业初始化的时候，直接从数据库将维表内容拷贝到内存中。

优点：

- 运行期间，不再访问数据库，基于内存，效率更高

缺点：

- 在作业启动时期，要拷贝整个维表，短时间内，数据库压力会比较大
- 作业运行期间，维表数据无法更新
- 对TaskManager的内存要求比较高（每一个SubTask，都有一份全量的维表数据）

应用场景：适用于维表数据较小，且变更实时要求不高或者维表更新较少的业务场景 [ 维表发生变更时，重启作业即可 ]

### 启动时预加载分区维表

在预加载维表的基础上新增分区功能。简言之，就是每个SubTask，都只加载分区范围内的维表数据。

> 该分区方式，并不是根据keyby这种通用的hash分区，而是根据业务数据定制化分区策略。

相比全量的预加载维表

优点：

- 大大减少了对TaskManager的内存要求（每一个SubTask只有1/N份数据。）

应用场景：适用于维表数据较大，且变更实时要求不高或者维表更新较少的业务场景

### 启动时预加载维表并定时刷新

预加载维表时，除了维表大小的限制，还有一个维表数据更新的问题。可以引入定时刷新的机制来缓解这个问题。

定时刷新可以通过 Flink 的 ProcessFuntion 提供的Timer 或者 直接在 `open() ` 时初始化一个线程来做这个事。

缺点：

- 每一次维表更新，都是一次数据库的请求高峰，数据库压力变大

应用场景：满足了有维表实时变更要求，但是不是特别高的场景

### 启动时预加载维表 + 实时数据库查询

预加载维表与实时数据库查询的混用，将预加载的维表数据作为缓存，提供实时关联使用，若未命中，则fallback到数据库进行查找。

应用场景：适合流量低，且维表更新较少的业务场景